Check system passwords for *
--- busybox-1.19.0/networking/httpd.c
+++ busybox-1.19.0/networking/httpd.c
@@ -54,6 +54,7 @@
  * /cgi-bin:foo:bar  # Require user foo, pwd bar on urls starting with /cgi-bin/
  * /adm:admin:setup  # Require user admin, pwd setup on urls starting with /adm/
  * /adm:toor:PaSsWd  # or user toor, pwd PaSsWd on urls starting with /adm/
+ * /adm:root:*       # or user root, pwd from /etc/passwd on urls starting with /adm/
  * .au:audio/basic   # additional mime type for audio.au files
  * *.php:/path/php   # run xxx.php through an interpreter
  *
@@ -123,6 +124,14 @@
 //usage:     "\n	-d STRING	URL decode STRING"
 
 #include "libbb.h"
+#if ENABLE_PAM
+/* PAM may include <locale.h>. We may need to undefine bbox's stub define: */
+# undef setlocale
+/* For some obscure reason, PAM is not in pam/xxx, but in security/xxx.
+ * Apparently they like to confuse people. */
+# include <security/pam_appl.h>
+# include <security/pam_misc.h>
+#endif
 #if ENABLE_FEATURE_HTTPD_USE_SENDFILE
 # include <sys/sendfile.h>
 #endif
@@ -1730,6 +1739,57 @@
 }
 
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
+
+#if ENABLE_PAM
+struct pam_userinfo {
+	char *name;
+	char *pw;
+};
+
+static int pam_talker(int num_msg,
+		        const struct pam_message ** msg,
+		        struct pam_response ** resp,
+		        void *appdata_ptr)
+{
+	int i;
+	struct pam_userinfo *userinfo = (struct pam_userinfo *) appdata_ptr;
+	struct pam_response *response;
+
+	if (!resp || !msg || !userinfo)
+		return PAM_CONV_ERR;
+
+	/* allocate memory to store response */
+	response = malloc(num_msg * sizeof(struct pam_response));
+	if (!response)
+		return PAM_CONV_ERR;
+
+	/* copy values */
+	for (i = 0; i < num_msg; i++) {
+		char *s;
+
+		switch (msg[i]->msg_style) {
+		case PAM_PROMPT_ECHO_ON:
+			s = userinfo->name;
+			break;
+		case PAM_PROMPT_ECHO_OFF:
+			s = userinfo->pw;
+			break;
+	        case PAM_ERROR_MSG:
+        	case PAM_TEXT_INFO:
+        		s = "";
+			break;
+		default:
+			free(response);
+			return PAM_CONV_ERR;
+		}
+		response[i].resp = strdup(s);
+		response[i].resp_retcode = PAM_SUCCESS;
+	}
+	*resp = response;
+	return PAM_SUCCESS;
+}
+#endif
+
 /*
  * Config file entries are of the form "/<path>:<user>:<passwd>".
  * If config file has no prefix match for path, access is allowed.
@@ -1745,7 +1805,7 @@
 	const char *prev = NULL;
 
 	for (cur = g_auth; cur; cur = cur->next) {
-		const char *dir_prefix;
+		const char *dir_prefix, *passwd;
 		size_t len;
 
 		dir_prefix = cur->before_colon;
@@ -1770,18 +1830,71 @@
 		/* Path match found */
 		prev = dir_prefix;
 
+		remoteuser = xstrndup(user_and_passwd,
+				strchrnul(user_and_passwd, ':') - user_and_passwd);
+		passwd = strchr(cur->after_colon, ':');
+
+		if (passwd && passwd[1] == '*' && passwd[2] == 0) {
+#if ENABLE_PAM
+			int r;
+			struct pam_userinfo userinfo = {NULL, NULL};
+			struct pam_conv conv_info = {&pam_talker, (void *) &userinfo};
+			pam_handle_t *pamh;
+
+			userinfo.name = remoteuser;
+			userinfo.pw = strchr(user_and_passwd, ':');
+
+			r = pam_start("httpd", remoteuser, &conv_info, &pamh) == PAM_SUCCESS
+			    && pam_authenticate(pamh, PAM_DISALLOW_NULL_AUTHTOK) == PAM_SUCCESS
+			    && pam_acct_mgmt(pamh, PAM_DISALLOW_NULL_AUTHTOK) == PAM_SUCCESS;
+			pam_end(pamh, PAM_SUCCESS);
+			if (r)
+				return 1; /* Ok */
+#else
+			struct passwd *pw = getpwnam(remoteuser);
+			if (pw) {
+#if ENABLE_FEATURE_SHADOWPASSWDS
+				/* Using _r function to avoid pulling in static buffers */
+				struct spwd spw;
+				char buffer[256];
+#endif
+				const char *correct =  pw->pw_passwd;
+				char *unencrypted = strchr(user_and_passwd, ':');
+				int r;
+
+				/* Don't check the password if password entry is empty (!) */
+				if (!correct[0])
+					return 1; /* Ok */
+#if ENABLE_FEATURE_SHADOWPASSWDS
+				if ((correct[0] == 'x' || correct[0] == '*') && !correct[1]) {
+					/* getspnam_r may return 0 yet set result to NULL.
+					 * At least glibc 2.4 does this. Be extra paranoid here. */
+					struct spwd *result = NULL;
+					r = getspnam_r(pw->pw_name, &spw, buffer, sizeof(buffer), &result);
+					correct = (r || !result) ? "aa" : result->sp_pwdp;
+				}
+#endif
+				if (correct[0] != '!' && correct[0] != '*') {
+					char *encrypted = pw_encrypt(unencrypted, correct, 1);
+					r = (strcmp(encrypted, correct) == 0);
+					free(encrypted);
+					if (r)
+						return 1; /* Ok */
+				}
+			}
+#endif // ENABLE_PAM
+			free(remoteuser);
+			continue;
+		}
 		if (ENABLE_FEATURE_HTTPD_AUTH_MD5) {
-			char *md5_passwd;
-
-			md5_passwd = strchr(cur->after_colon, ':');
-			if (md5_passwd && md5_passwd[1] == '$' && md5_passwd[2] == '1'
-			 && md5_passwd[3] == '$' && md5_passwd[4]
+			if (passwd && passwd[1] == '$' && passwd[2] == '1'
+			 && passwd[3] == '$' && passwd[4]
 			) {
 				char *encrypted;
 				int r, user_len_p1;
 
-				md5_passwd++;
-				user_len_p1 = md5_passwd - cur->after_colon;
+				passwd++;
+				user_len_p1 = passwd - cur->after_colon;
 				/* comparing "user:" */
 				if (strncmp(cur->after_colon, user_and_passwd, user_len_p1) != 0) {
 					continue;
@@ -1789,22 +1902,20 @@
 
 				encrypted = pw_encrypt(
 					user_and_passwd + user_len_p1 /* cleartext pwd from user */,
-					md5_passwd /*salt */, 1 /* cleanup */);
-				r = strcmp(encrypted, md5_passwd);
+					passwd /*salt */, 1 /* cleanup */);
+				r = strcmp(encrypted, passwd);
 				free(encrypted);
 				if (r == 0)
-					goto set_remoteuser_var; /* Ok */
+					return 1; /* Ok */
 				continue;
 			}
 		}
 
 		/* Comparing plaintext "user:pass" in one go */
-		if (strcmp(cur->after_colon, user_and_passwd) == 0) {
- set_remoteuser_var:
-			remoteuser = xstrndup(user_and_passwd,
-					strchrnul(user_and_passwd, ':') - user_and_passwd);
+		if (strcmp(cur->after_colon, user_and_passwd) == 0)
 			return 1; /* Ok */
-		}
+		free(remoteuser);
+		remoteuser = NULL;
 	} /* for */
 
 	/* 0(bad) if prev is set: matches were found but passwd was wrong */
