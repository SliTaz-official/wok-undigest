Add framebuffer support + small shrink
   text	   data	    bss	    dec	    hex	filename
   2570	      0	      0	   2570	    a0a	miscutils.org/conspy.o
   2514	      0	      0	   2514	    9d2	miscutils/conspy.o
--- busybox-1.19.0/miscutils/conspy.c
+++ busybox-1.19.0/miscutils/conspy.c
@@ -23,19 +23,28 @@
 //config:	  example:  conspy NUM      shared access to console num
 //config:	  or        conspy -nd NUM  screenshot of console num
 //config:	  or        conspy -cs NUM  poor man's GNU screen like
+//config:
+//config:config CONSPY_FRAMEBUFFER
+//config:	bool "framebuffer support"
+//config:	default n
+//config:	depends on CONSPY
+//config:	help
+//config:	  Framebuffer console is supported by -F option.
 
 //usage:#define conspy_trivial_usage
-//usage:	"[-vcsndf] [-x COL] [-y LINE] [CONSOLE_NO]"
+//usage:	"[-v" IF_PLATFORM_LINUX("c") "Qsndf" IF_CONSPY_FRAMEBUFFER("F") "] [-x COL] [-y LINE] [CONSOLE_NO]"
 //usage:#define conspy_full_usage "\n\n"
 //usage:     "A text-mode VNC like program for Linux virtual consoles."
 //usage:     "\nTo exit, quickly press ESC 3 times."
 //usage:     "\n"
 //usage:     "\n	-v	Don't send keystrokes to the console"
-//usage:     "\n	-c	Create missing devices in /dev"
+//usage:     "\n	-Q	Never exit"
+//usage:     IF_PLATFORM_LINUX("\n	-c	Create missing devices in /dev")
 //usage:     "\n	-s	Open a SHELL session"
 //usage:     "\n	-n	Black & white"
 //usage:     "\n	-d	Dump console to stdout"
 //usage:     "\n	-f	Follow cursor"
+//usage:     IF_CONSPY_FRAMEBUFFER("\n	-F	Console in framebuffer")
 //usage:     "\n	-x COL	Starting column"
 //usage:     "\n	-y LINE	Starting line"
 
@@ -44,7 +54,17 @@
 
 
 #define ESC "\033"
+#define CURSOR_ON	-1
+#define CURSOR_OFF	1
 
+#if ENABLE_PLATFORM_LINUX
+#define DEV_TTY		"/dev/tty"
+#define DEV_VCSA	"/dev/vcsa"
+#else
+#define DEV_TTY		"/dev/vc/"
+#define DEV_VCSA	"/dev/vcc/a"
+#endif
+
 struct screen_info {
 	unsigned char lines, cols, cursor_x, cursor_y;
 };
@@ -72,38 +92,44 @@
 	unsigned col;
 	unsigned line;
 	smallint curoff; // unknown:0 cursor on:-1 cursor off:1
-	char attrbuf[sizeof(ESC"[0;1;5;30;40m")];
+	char attrbuf[sizeof("0;1;5;30;40m")];
 	// remote console
 	struct screen_info remote;
 	// saved local tty terminfo
 	struct termios term_orig;
-	char vcsa_name[sizeof("/dev/vcsaNN")];
+	char vcsa_name[sizeof(DEV_VCSA "NN")];
 };
 
 #define G (*ptr_to_globals)
 #define INIT_G() do { \
 	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
-	G.attrbuf[0] = '\033'; \
-	G.attrbuf[1] = '['; \
 	G.width = G.height = UINT_MAX; \
 	G.last_attr--; \
 } while (0)
 
 enum {
 	FLAG_v,  // view only
 	FLAG_c,  // create device if need
+	FLAG_Q,  // never exit
 	FLAG_s,  // session
 	FLAG_n,  // no colors
 	FLAG_d,  // dump screen
 	FLAG_f,  // follow cursor
+	FLAG_F,  // framebuffer
 };
 #define FLAG(x) (1 << FLAG_##x)
 #define BW (option_mask32 & FLAG(n))
 
+static void putcsi(const char *s)
+{
+	fputs(ESC"[", stdout);
+	fputs(s, stdout);
+}
+
 static void clrscr(void)
 {
 	// Home, clear till end of screen
-	fputs(ESC"[1;1H" ESC"[J", stdout);
+	putcsi("1;1H" ESC"[J");
 	G.col = G.line = 0;
 }
 
@@ -111,7 +137,7 @@
 {
 	if (G.curoff != state) {
 		G.curoff = state;
-		fputs(ESC"[?25", stdout);
+		putcsi("?25");
 		bb_putchar("h?l"[1 + state]);
 	}
 }
@@ -125,18 +151,19 @@
 	}
 }
 
+static void cleanup(int code) NORETURN;
 static void cleanup(int code)
 {
-	set_cursor(-1); // cursor on
+	set_cursor(CURSOR_ON);
 	tcsetattr(G.kbd_fd, TCSANOW, &G.term_orig);
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		close(G.kbd_fd);
 	}
 	// Reset attributes
 	if (!BW)
-		fputs(ESC"[0m", stdout);
+		putcsi("0m");
 	bb_putchar('\n');
-	if (code > 1)
+	if (code > EXIT_FAILURE)
 		kill_myself_with_sig(code);
 	exit(code);
 }
@@ -157,8 +184,8 @@
 		G.size = i;
 		G.data = xzalloc(2 * i);
 	}
-	else if (G.size != i) {
-		cleanup(1);
+	if (G.size != i) {
+		cleanup(EXIT_FAILURE);
 	}
 	data = G.data + G.current;
 	xread(vcsa_fd, data, G.size);
@@ -179,10 +206,15 @@
 static void screen_char(char *data)
 {
 	if (!BW) {
+		uint8_t attr_diff;
 		uint8_t attr = ATTR(data);
-		//uint8_t attr = ATTR(data) >> 1; // for framebuffer console
-		uint8_t attr_diff = G.last_attr ^ attr;
 
+#if ENABLE_CONSPY_FRAMEBUFFER
+		if (option_mask32 & FLAG(F)) {
+			attr >>= 1;
+		}
+#endif
+		attr_diff = G.last_attr ^ attr;
 		if (attr_diff) {
 // Attribute layout for VGA compatible text videobuffer:
 // blinking text
@@ -213,7 +245,7 @@
 			const uint8_t bg_mask = 0x70, blink_mask = 0x80;
 			char *ptr;
 
-			ptr = G.attrbuf + 2; // skip "ESC ["
+			ptr = G.attrbuf;
 
 			// (G.last_attr & ~attr) has 1 only where
 			// G.last_attr has 1 but attr has 0.
@@ -244,16 +276,16 @@
 			if (attr_diff & bg_mask) {
 				*ptr++ = '4';
 				*ptr++ = color[(attr & bg_mask) >> 4];
-				*ptr++ = ';';
+				ptr++; // last attribute
 			}
-			if (ptr != G.attrbuf + 2) {
+			if (ptr != G.attrbuf) {
 				ptr[-1] = 'm';
 				*ptr = '\0';
-				fputs(G.attrbuf, stdout);
+				putcsi(G.attrbuf);
 			}
 		}
 	}
-	putchar(CHAR(data));
+	bb_putchar(CHAR(data));
 	G.col++;
 }
 
@@ -292,15 +324,16 @@
 {
 	unsigned cx = G.remote.cursor_x - G.x;
 	unsigned cy = G.remote.cursor_y - G.y;
-	int cursor = 1;
+	int cursor = CURSOR_OFF;
 
 	if (cx < G.width && cy < G.height) {
 		gotoxy(cx, cy);
-		cursor = -1;
+		cursor = CURSOR_ON;
 	}
 	set_cursor(cursor);
 }
 
+#if ENABLE_PLATFORM_LINUX
 static void create_cdev_if_doesnt_exist(const char* name, dev_t dev)
 {
 	int fd = open(name, O_RDONLY);
@@ -309,6 +342,7 @@
 	else if (errno == ENOENT)
 		mknod(name, S_IFCHR | 0660, dev);
 }
+#endif
 
 static NOINLINE void start_shell_in_child(const char* tty_name)
 {
@@ -341,7 +377,7 @@
 int conspy_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int conspy_main(int argc UNUSED_PARAM, char **argv)
 {
-	char tty_name[sizeof("/dev/ttyNN")];
+	char tty_name[sizeof(DEV_TTY "NN")];
 #define keybuf bb_common_bufsiz1
 	struct termios termbuf;
 	unsigned opts;
@@ -350,32 +386,36 @@
 #if ENABLE_LONG_OPTS
 	static const char getopt_longopts[] ALIGN1 =
 		"viewonly\0"     No_argument "v"
-		"createdevice\0" No_argument "c"
+		"neverquit\0"    No_argument "Q"
+		IF_PLATFORM_LINUX("createdevice\0" No_argument "c")
 		"session\0"      No_argument "s"
 		"nocolors\0"     No_argument "n"
 		"dump\0"         No_argument "d"
 		"follow\0"       No_argument "f"
+		IF_CONSPY_FRAMEBUFFER("framebuffer\0"  No_argument "F")
 		;
 
 	applet_long_options = getopt_longopts;
 #endif
 	INIT_G();
-	strcpy(G.vcsa_name, "/dev/vcsa");
+	strcpy(G.vcsa_name, DEV_VCSA);
 
 	opt_complementary = "x+:y+"; // numeric params
-	opts = getopt32(argv, "vcsndfx:y:", &G.x, &G.y);
+	opts = getopt32(argv, "vcQsndf" IF_CONSPY_FRAMEBUFFER("F") "x:y:", &G.x, &G.y);
 	argv += optind;
 	ttynum = 0;
 	if (argv[0]) {
 		ttynum = xatou_range(argv[0], 0, 63);
-		sprintf(G.vcsa_name + sizeof("/dev/vcsa")-1, "%u", ttynum);
+		sprintf(G.vcsa_name + sizeof(DEV_VCSA)-1, "%u", ttynum);
 	}
-	sprintf(tty_name, "%s%u", "/dev/tty", ttynum);
+	sprintf(tty_name, "%s%u", DEV_TTY, ttynum);
+#if ENABLE_PLATFORM_LINUX
 	if (opts & FLAG(c)) {
 		if ((opts & (FLAG(s)|FLAG(v))) != FLAG(v))
 			create_cdev_if_doesnt_exist(tty_name, makedev(4, ttynum));
 		create_cdev_if_doesnt_exist(G.vcsa_name, makedev(7, 128 + ttynum));
 	}
+#endif
 	if ((opts & FLAG(s)) && ttynum) {
 		start_shell_in_child(tty_name);
 	}
@@ -481,7 +521,7 @@
 			char *k;
 		case -1:
 			if (errno != EINTR)
-				cleanup(1);
+				goto abort;
 			break;
 		case 0:
 			if (++G.nokeys >= 4)
@@ -492,14 +532,16 @@
 			k = keybuf + G.key_count;
 			bytes_read = read(G.kbd_fd, k, sizeof(keybuf) - G.key_count);
 			if (bytes_read < 0)
-				cleanup(1);
+				goto abort;
 
 			// Do exit processing
-			for (i = 0; i < bytes_read; i++) {
-				if (k[i] != '\033')
-					G.escape_count = 0;
-				else if (++G.escape_count >= 3)
-					cleanup(0);
+			if (!(option_mask32 & FLAG(Q))) {
+				for (i = 0; i < bytes_read; i++) {
+					if (k[i] != '\033')
+						G.escape_count = -1;
+					if (++G.escape_count >= 3)
+						cleanup(EXIT_SUCCESS);
+				}
 			}
 		}
 		poll_timeout_ms = 250;
@@ -519,6 +561,7 @@
 			if (result >= 0) {
 				char *p = keybuf;
 
+				G.ioerror_count = 0;
 				if (kbd_mode != K_XLATE && kbd_mode != K_UNICODE) {
 					G.key_count = 0; // scan code mode
 				}
@@ -534,16 +577,18 @@
 					poll_timeout_ms = 20;
 				}
 			}
+			// We sometimes get spurious IO errors on the TTY
+			// as programs close and re-open it
+			else if (errno != EIO || ++G.ioerror_count > 4) {
+				if (ENABLE_FEATURE_CLEAN_UP)
+					close(handle);
+				goto abort;
+			}
 			// Close & re-open tty in case they have
 			// swapped virtual consoles
 			close(handle);
-
-			// We sometimes get spurious IO errors on the TTY
-			// as programs close and re-open it
-			if (result >= 0)
-				G.ioerror_count = 0;
-			else if (errno != EIO || ++G.ioerror_count > 4)
-				cleanup(1);
 		}
 	} /* while (1) */
+  abort:
+	cleanup(EXIT_FAILURE);
 }
